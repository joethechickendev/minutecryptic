<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cryptic</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="chat-container">

        <div class="message-area">
            <div id="date-0" class="date"></div>
            <div id="typing-bubble-0" class="message typing-bubble-received hidden">
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
            </div>

            <div id="clue-mount-0" class="message received hidden"></div>

            <div id="typing-bubble-1" class="message typing-bubble-sent hidden">
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
            </div>
            
            <div id="clue-mount-1" class="message sent hidden"></div>

            <div id="date-1" class="date hidden"></div>

            <div id="typing-bubble-2" class="message typing-bubble-sent hidden">
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
            </div>

            <div id="clue-mount-2" class="message sent hidden"></div>

            <div id="typing-bubble-3" class="message typing-bubble-received hidden">
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
            </div>

            <div id="clue-mount-3" class="message received hidden"></div>

            <div id="date-2" class="date hidden"></div>

            <div id="typing-bubble-4" class="message typing-bubble-sent hidden">
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
            </div>

            <div id="clue-mount-4" class="message sent hidden"></div>

            <div id="typing-bubble-5" class="message typing-bubble-received hidden">
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
            </div>

            <div id="clue-mount-5" class="message received hidden"></div>

        </div>
    </div>
</body>

<script>
const solved = []; // global to track which clues have been completed
let clues;

function createCrypticClue({ answer, clue, index }) {
    if(solved.length < index - 1){
        solved.push(false)
    } else{
        solved[index] = false;
    }
    const root = document.createElement("div");
    root.className = "cryptic-clue";

    let clueHTML = "";
    if (Array.isArray(clue)) {
        clueHTML = clue.map(part => 
            `<span class="${part.type}">${part.string}</span>`
        ).join(" ");
    } else {
        clueHTML = clue; // Fallback for simple strings
    }

    root.innerHTML = `
        <div class="center">
            <div class="prompt">${clueHTML}</div>
            <div class="answer-row"></div>
            <div class="numHint" style="text-align:center; font-size: 0.8em; margin-top:5px;"></div>
            <div class="buttonRow">
                <div class="mainButtonRow">
                    <button class="hintBtn">Hint</button>
                    <button class="checkBtn">Check</button>
                </div>
                <div class="hintButtonRow hidden" style="width: 100%; gap: 10px;">
                    <button class="defBtn">Definition</button>
                    <button class="fodderBtn">Fodder</button>
                    <button class="indBtn">Indicators</button>
                    <button class="letBtn">Letter</button>
                </div>
            </div>
        </div>
    `;

    const row = root.querySelector(".answer-row");

    const answerChars = [...answer];

    console.log(answerChars)

    answerChars.forEach((ch, idx) => {
        const input = document.createElement("input"); 
        input.className = "letter-box";
        input.maxLength = 1;
        input.autocomplete = "off";
        input.spellcheck = false;
        input.dataset.index = idx;
    
        if (ch === " ") {
            input.value = "-";      // Set the dash
            input.readOnly = true;  // Prevent typing
            input.tabIndex = -1;    // Skip when tabbing
            input.classList.add("separator");
        }
    
        row.appendChild(input);
    });

    const boxes = Array.from(root.querySelectorAll(".letter-box"));

    const getValidBox = (index, direction) => {
        let nextIdx = index + direction;
        while (boxes[nextIdx] && boxes[nextIdx].readOnly) {
            nextIdx += direction;
        }
        return boxes[nextIdx];
    };

    boxes.forEach((box, idx) => {
      box.addEventListener("input", () => {
        if (box.readOnly) return; 
        box.value = box.value.slice(0, 1);
        
        if (box.value) {
            const next = getValidBox(idx, 1);
            if (next) next.focus();
        }
        updateCheckEnabled();
    });

      box.addEventListener("keydown", (e) => {
        const key = e.key;

        if (e.key === "Backspace" && !box.value) {
            e.preventDefault();
            const prev = getValidBox(idx, -1);
            if (prev) {
                prev.focus();
                prev.value = "";
            }
        } else if (e.key === "ArrowLeft") {
            e.preventDefault();
            const prev = getValidBox(idx, -1);
            if (prev) prev.focus();
        } else if (e.key === "ArrowRight") {
            e.preventDefault();
            const next = getValidBox(idx, 1);
            if (next) next.focus();
        } else if (e.key === "Enter" {
            e.preventDefault();
            checkAnswer();
        }

        updateCheckEnabled();
      });
    });

    // Focus first box on load
    if (boxes[0]) boxes[0].focus();

    const checkBtn = root.querySelector(".checkBtn");
    const hintBtn = root.querySelector(".hintBtn");
    const defBtn = root.querySelector(".defBtn");
    const fodderBtn = root.querySelector(".fodderBtn");
    const indBtn = root.querySelector(".indBtn");
    const letBtn = root.querySelector(".letBtn");
    const numberHint = root.querySelector(".numHint");
    const hintBtnRow = root.querySelector(".hintButtonRow");
    const mnBtnRow = root.querySelector(".mainButtonRow");

    let answerLengths = [0];

    for(var i = 0; i < answer.length; i++) {
        if(answer[i] == " ") {
            answerLengths.push(0);
        } else {
            answerLengths[answerLengths.length - 1]++;
        }
    }
    
    numberHint.innerText = "(" + answerLengths.join(", ") + ")"

    let hints = {
        def: false,
        fodder: false,
        ind: false,
        letters: []
    };

    for(let i = 0; i < answer.length; i++) {
        answer[i] !== " " && hints.letters.push(i);
    }

    let lettersStartingLength = hints.letters.length;

    function getHints() {
        let a = 0;
        a += hints.def ? 1 : 0;
        a += hints.fodder ? 1 : 0;
        a += hints.ind ? 1 : 0;
        a += lettersStartingLength - hints.letters.length;

        return a;
    }

    function updateHints() {
        let area = document.querySelector(".message-area");
        let message;

        for(let i = 0; i < area.children.length; i++) {
            if(area.children[i].querySelector(".par")) {
                message = area.children[i];
            }
        }

        if(!message) {
            return;
        }

        const parLabel = message.children[0];
        let a = parLabel.innerHTML.split(" (");
        let score = getHints() - parseInt(a[1].split(" ")[1]);

        if(score > 0) {
            a[0] = `Score: +${score}`
        } else {
            a[0] = `Score: ${score}`
        }

        parLabel.innerHTML = a.join(" (");

        const par = message.children[1];

        console.log(`Updating ${par.children.length} for hints = ${getHints()}`);
        for(let i = 0; i < par.children.length; i++) {
            if(i < getHints()) {
                par.children[i].classList.add("used");
            }
        }
    }

    hintBtn.addEventListener("click", () => {
        if (hintBtnRow.classList.contains("hidden")) {
            hintBtnRow.classList.remove("hidden");
        } else {
            hintBtnRow.classList.add("hidden");
        }
    })

    defBtn.addEventListener("click", () => {
        const defSpans = root.querySelectorAll(".def");
        defSpans.forEach(span => span.style.textDecoration = "underline 3px #59cafa");
        
        const puzzleData = JSON.parse(atob(urlParams.get("puzzle").replace(/ /g, '+')));
        if(puzzleData.hint && puzzleData.hint.def) {
            sendHintBubble("the definition", puzzleData.hint.def, puzzleData.character);
            hints.def = true;
        }
        defBtn.disabled = true;

        updateHints();
    });

    fodderBtn.addEventListener("click", () => {
        const fodderSpans = root.querySelectorAll(".fodder");
        fodderSpans.forEach(span => span.style.textDecoration = "underline 3px #ffd016");
        
        const puzzleData = JSON.parse(atob(urlParams.get("puzzle").replace(/ /g, '+')));
        if(puzzleData.hint && puzzleData.hint.fodder) {
            sendHintBubble("the fodder", puzzleData.hint.fodder, puzzleData.character);
            hints.fodder = true;
        }
        fodderBtn.disabled = true;

        updateHints();
    });

    indBtn.addEventListener("click", () => {
        const indSpans = root.querySelectorAll(".ind");
        indSpans.forEach(span => span.style.textDecoration = "underline 3px #fe6dbd");
        
        const puzzleData = JSON.parse(atob(urlParams.get("puzzle").replace(/ /g, '+')));
        if(puzzleData.hint && puzzleData.hint.ind) {
            sendHintBubble("the indicators", puzzleData.hint.ind, puzzleData.character);
            hints.ind = true;
        }
        indBtn.disabled = true;

        updateHints();
    });

    letBtn.addEventListener("click", () => {
        let random = Math.floor(Math.random() * hints.letters.length);
        let letter = hints.letters[random];

        const box = root.querySelectorAll(".letter-box")[letter];
        box.style.backgroundColor = "#66eda1";
        box.value = answer[box.dataset.index];
        box.readOnly = true;
        box.disabled = true;

        hints.letters.splice(random, 1);
        updateCheckEnabled();
        updateHints();

        if(hints.letters.length == 0) {
            letBtn.disabled = true;
        } 
    });

    function updateMessages({ par, hintsUsed }) {
        let diff = hintsUsed - par;
        let message = {
            character: 1,
            message: "light work"
        };

        switch (diff) {
            case(-3):
                message.message = "im a eagle"
                break;
            case(-2):
                message.message = "bravo"
                break;
            case(-1):
                message.message = "easy"
                break;
            case(0):
                message.message = "thanks twin"
                break;
            case(1):
                message.message = "twin you set the par too high"
                break;
            default:
                if(diff > 0) {
                    message.message = "yeah uhh light work"
                } else {
                    message.message = "can I get a gold star?"
                }
                break;
        }

        if(hintsUsed == 0) {
            message.message = "light work"
        }

        clues.push(message);
    }

    checkBtn.addEventListener("click", checkAnswer());
    
    function checkAnswer() {
        const guess = boxes.map(b => b.value === "-" ? " " : b.value).join("");
        const correct = guess.toLowerCase() === answer.toLowerCase();
    
        if (!correct) {
            // shake animation
            row.classList.remove("shake");
            void row.offsetWidth;
            row.classList.add("shake");
    
            setTimeout(() => {
            row.classList.remove("shake");
            }, 250);
        } else {
            const buttonRow = root.querySelector(".buttonRow");
            buttonRow.classList.add("hidden");
            hintBtnRow.classList.add("hidden");
            mnBtnRow.classList.add("hidden");
    
            boxes.forEach(element => {
                element.style.backgroundColor = "#f9a8d4";
                element.disabled = true;
            });
    
            solved[index] = true;
    
            const puzzleData = JSON.parse(atob(urlParams.get("puzzle").replace(/ /g, '+')));
            updateMessages({ par: puzzleData.par || NaN, hintsUsed: getHints() });
        }
    }

    function updateCheckEnabled() {
        const allFilled = boxes.every(b => b.value.trim().length === 1);
        checkBtn.disabled = !allFilled;
    }

    updateCheckEnabled();

    return root;
};

function waitForI(i) {
  return new Promise(resolve => {
    function checkFlag() {
      if (solved[i]) {
        resolve();
      } else {
        window.setTimeout(checkFlag, 500); 
      }
    }
    checkFlag();
  });
}

const intro = [
    {
        date: 0,
        character: 0,
        message: "What's up!"
    },
    {
        character: 0,
        message: `Looks like someone sent you a puzzle...`,
    }
];

function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    // Generate random index from 0 to i
    const j = Math.floor(Math.random() * (i + 1));
    // Swap elements [array[i], array[j]]
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

const urlParams = new URLSearchParams(window.location.search);

console.log(urlParams.get("puzzle").replace(/ /g, '+'));

clues = [...intro];
let clue = JSON.parse(atob(urlParams.get("puzzle").replace(/ /g, '+')));

if(clue.par) {clues.push({parThis: clue.par, character: 0}); clue.time = 0;}
clues.push(clue);

function createBubble({ sent }){
    const root = document.createElement("div");
    root.classList.add(sent === 0 ? "bubbleSentDiv" : "bubbleReceivedDiv");
    const sentBubbleHTML = `
    <div class="message typing-bubble-${sent === 0 ? "sent" : "received"}">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
    </div>
    `
    root.innerHTML = sentBubbleHTML;
    return root;
}

function createDate( {date_mod} ){
    const root = document.createElement("div");
    root.classList.add("date");

    const dateO = new Date();
    dateO.setDate(dateO.getDate() + date_mod)
    const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
    const localeDateString = dateO.toLocaleDateString('en-US', options);
    root.innerHTML = localeDateString;

    return root;
}

function createParMessage({ sent, par, length }){
    const root = document.createElement("div");

    root.classList.add("message");
    root.classList.add(sent === 0 ? "sent" : "received");

    const parMessage = document.createElement("div");
    parMessage.classList.add("par");
    parMessage.classList.add("buttonRow");

    for(let i = 0; i < length; i++) {
        const circle = document.createElement("div");
        circle.classList.add("circle");
        if(i < par) circle.classList.add("on-par");
        parMessage.appendChild(circle);
    }

    const parLabel = document.createElement("div");
    parLabel.classList.add("par-number");
    parLabel.innerHTML = (`Score: -${par} (Par ${par})`);

    root.appendChild(parLabel);
    root.appendChild(parMessage);

    return root;
}

function createClueMessage({ sent }){
    const root = document.createElement("div");

    root.classList.add("message");
    root.classList.add(sent === 0 ? "sent" : "received");

    return root;
}

function createWordMessage({ sent, message }){
    const root = document.createElement("div");

    root.classList.add("message");
    root.classList.add(sent === 0 ? "sent" : "received");
    root.innerHTML = message;

    return root;
}

// Function to add a new message bubble to the chat area
function sendHintBubble(type, hintList, character) {
    if (!hintList || hintList.length === 0) return;

    const listItems = hintList.map(h => `<li>${h}</li>`).join("");
    const message = `
        Here are the hints for ${type}:
        <ul style="margin: 5px 0; padding-left: 20px;">${listItems}</ul>
    `;
    
    const bubble = createWordMessage({ sent: character, message: message });
    scrollable.appendChild(bubble);
    scrollable.scrollTop = scrollable.scrollHeight;
}


const scrollable = document.querySelector(".message-area");

function timeout(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

async function run(){
    let z = 0;
    while(z < clues.length){

        await timeout(clues[z].wait != null ? clues[z].wait : 0)

        if(clues[z].date != null){
            scrollable.appendChild(createDate({date_mod: clues[z].date}))
        }
        scrollable.appendChild(createBubble({sent: clues[z].character}))
        scrollable.scrollTop = scrollable.scrollHeight;
        let timeToBubble = clues[z].time != null ? clues[z].time : 2000
        setTimeout(() => {
        scrollable.removeChild(scrollable.lastElementChild)
        if(clues[z].message != null){
            scrollable.appendChild(createWordMessage({sent: clues[z].character, message: clues[z].message}))
            solved[z] = true;
        } else{
            if(clues[z].parThis){
                scrollable.appendChild(createParMessage({sent: clues[z].character, par: clues[z].parThis, length: clue.answer.length + 3}));
                solved[z] = true;
            } else{
                scrollable.appendChild(createClueMessage({sent: clues[z].character}))
                scrollable.lastElementChild.appendChild(createCrypticClue({
                    answer: clues[z].answer,
                    clue: clues[z].clue,
                    index: z
                }));
            }
        }
        scrollable.scrollTop = scrollable.scrollHeight;
        }, timeToBubble);

        await waitForI(z);
        z++;
    }
}

run();

</script>

</html>
